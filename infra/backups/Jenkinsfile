pipeline {
    agent any
    
    options {
        timestamps()
        ansiColor('xterm')
        timeout(time: 2, unit: 'HOURS')
        buildDiscarder(logRotator(numToKeepStr: '30'))
    }

    // Les variables d'environnement seront d√©finies apr√®s le chargement du fichier .env
    // dans le stage Load Environment pour √©viter les valeurs null

    parameters {
        booleanParam(
            name: 'RUN_RESTORE_TEST', 
            defaultValue: false, 
            description: 'Ex√©cuter un test de restauration apr√®s la sauvegarde'
        )
        choice(
            name: 'BACKUP_TYPE',
            choices: ['daily', 'manual', 'full'],
            description: 'Type de sauvegarde √† effectuer'
        )
        string(
            name: 'RESTORE_PATH',
            defaultValue: '/backup/jenkins/jobs',
            description: 'Chemin √† restaurer pour le test (si activ√©)'
        )
    }

    triggers {
        // Sauvegarde quotidienne √† 2h du matin (heure al√©atoire pour √©viter la surcharge)
        cron('H 2 * * *')
    }

    stages {
        stage('Load Environment') {
            steps {
                script {
                    echo "üìã Chargement des variables d'environnement..."
                    // Charger les variables du fichier .env
                    def envVars = readFile('.env').split('\n')
                    envVars.each { line ->
                        if (line.trim() && !line.startsWith('#')) {
                            def parts = line.split('=', 2)
                            if (parts.length == 2) {
                                env."${parts[0].trim()}" = parts[1].trim()
                            }
                        }
                    }
                    
                    // D√©finir les variables d√©riv√©es apr√®s le chargement du .env
                    env.RESTIC_REPOSITORY = "s3:http://minio:9000/${env.MINIO_BACKUP_BUCKET}"
                    env.PUSHGATEWAY_URL = "http://pushgateway:9091"
                    
                    echo "‚úÖ Variables d'environnement charg√©es"
                    echo "RESTIC_REPOSITORY: ${env.RESTIC_REPOSITORY}"
                    echo "BACKUP_HOSTNAME: ${env.BACKUP_HOSTNAME}"
                    echo "PUSHGATEWAY_URL: ${env.PUSHGATEWAY_URL}"
                }
            }
        }
        
        stage('Pre-backup Checks') {
            steps {
                script {
                    echo "üîç V√©rification de l'environnement de sauvegarde..."
                    
                    // V√©rifier que les conteneurs n√©cessaires sont en cours d'ex√©cution
                    sh '''
                        echo "V√©rification des conteneurs..."
                        docker ps --format "table {{.Names}}\\t{{.Status}}" | grep -E "(minio|restic-runner)"
                        
                        echo "V√©rification de l'espace disque disponible..."
                        df -h /tmp
                        
                        echo "V√©rification de la connectivit√© MinIO via r√©seau Docker..."
                        # Test direct via le nom du conteneur sur le r√©seau Docker
                        docker exec restic-runner bash -c '
                            echo "Test de connectivit√© MinIO via nom de conteneur..."
                            curl -f --max-time 10 http://minio:9000/minio/health/live || echo "ATTENTION: MinIO health endpoint non accessible (normal)"
                            
                            echo "Test de connectivit√© MinIO API..."
                            curl -f --max-time 10 http://minio:9000/ || echo "ATTENTION: MinIO API non accessible"
                            
                            echo "V√©rification des variables d environnement..."
                            echo "RESTIC_REPOSITORY=" $RESTIC_REPOSITORY
                        '
                        
                        echo "Variables depuis .env:"
                        echo "MINIO_API_HOST: ${MINIO_API_HOST}"
                        echo "MINIO_BACKUP_BUCKET: ${MINIO_BACKUP_BUCKET}"
                        
                        echo "V√©rification/cr√©ation du bucket MinIO..."
                        docker exec restic-runner bash -c '
                            # Test si le bucket existe via restic (qui utilise les credentials)
                            export AWS_ACCESS_KEY_ID="${AWS_ACCESS_KEY_ID:-}"
                            export AWS_SECRET_ACCESS_KEY="${AWS_SECRET_ACCESS_KEY:-}"
                            if [ -n "$AWS_ACCESS_KEY_ID" ] && [ -n "$AWS_SECRET_ACCESS_KEY" ]; then
                                echo "Test de connectivit√© S3 avec credentials..."
                                restic -r $RESTIC_REPOSITORY snapshots 2>/dev/null || echo "Repository pas encore initialis√© (normal pour la premi√®re fois)"
                            else
                                echo "Credentials MinIO non disponibles dans cette √©tape (seront fournis dans Backup Workflow)"
                            fi
                        '
                    '''
                }
            }
        }

        stage('Backup Workflow') {
            steps {
                script {
                    echo "üöÄ D√©marrage de la sauvegarde ${params.BACKUP_TYPE}..."
                }
                
                withCredentials([
                    file(credentialsId: 'restic-password-file', variable: 'RESTIC_PASSWORD_FILE'),
                    string(credentialsId: 'minio-access-key', variable: 'AWS_ACCESS_KEY_ID'),
                    string(credentialsId: 'minio-secret-key', variable: 'AWS_SECRET_ACCESS_KEY')
                ]) {
                    sh '''
                        # Export des variables d'environnement pour le conteneur
                        export BACKUP_START_TIME=$(date +%s)
                        
                        echo "üì¶ Ex√©cution de la sauvegarde dans le conteneur restic-runner..."
                        
                        # Copier le fichier de mot de passe dans le conteneur
                        docker exec restic-runner mkdir -p /secrets
                        docker cp "$RESTIC_PASSWORD_FILE" restic-runner:/secrets/restic_password
                        docker exec restic-runner chmod 600 /secrets/restic_password
                        
                        # Ex√©cuter la sauvegarde
                        docker exec \
                            -e RESTIC_REPOSITORY \
                            -e AWS_ACCESS_KEY_ID \
                            -e AWS_SECRET_ACCESS_KEY \
                            -e BACKUP_HOSTNAME \
                            -e PUSHGATEWAY_URL \
                            -e RESTIC_PASSWORD_FILE=/secrets/restic_password \
                            restic-runner bash -c "/backup-scripts/backup.sh"
                        
                        echo "‚úÖ Sauvegarde termin√©e avec succ√®s"
                    '''
                }
            }
            
            post {
                failure {
                    script {
                        echo "‚ùå √âchec de la sauvegarde"
                        // Envoyer une m√©trique d'√©chec
                        withCredentials([
                            string(credentialsId: 'minio-access-key', variable: 'AWS_ACCESS_KEY_ID'),
                            string(credentialsId: 'minio-secret-key', variable: 'AWS_SECRET_ACCESS_KEY')
                        ]) {
                            sh '''
                                docker exec \
                                    -e PUSHGATEWAY_URL \
                                    -e BACKUP_HOSTNAME \
                                    restic-runner sh -c '
                                        if [ -n "${PUSHGATEWAY_URL}" ]; then
                                            echo "restic_backup_success 0" | curl --data-binary @- "${PUSHGATEWAY_URL}/metrics/job/restic_backup/instance/${BACKUP_HOSTNAME}" --max-time 10 --silent || true
                                        fi
                                    '
                            '''
                        }
                    }
                }
            }
        }

        stage('Backup Verification') {
            steps {
                script {
                    echo "üîç V√©rification de la sauvegarde..."
                }
                
                withCredentials([
                    file(credentialsId: 'restic-password-file', variable: 'RESTIC_PASSWORD_FILE'),
                    string(credentialsId: 'minio-access-key', variable: 'AWS_ACCESS_KEY_ID'),
                    string(credentialsId: 'minio-secret-key', variable: 'AWS_SECRET_ACCESS_KEY')
                ]) {
                    sh '''
                        echo "üìä Affichage des snapshots r√©cents..."
                        
                        # Copier le fichier de mot de passe dans le conteneur
                        docker exec restic-runner mkdir -p /secrets
                        docker cp "$RESTIC_PASSWORD_FILE" restic-runner:/secrets/restic_password
                        docker exec restic-runner chmod 600 /secrets/restic_password
                        
                        # V√©rifier les snapshots
                        docker exec \
                            -e RESTIC_REPOSITORY \
                            -e AWS_ACCESS_KEY_ID \
                            -e AWS_SECRET_ACCESS_KEY \
                            -e RESTIC_PASSWORD_FILE=/secrets/restic_password \
                            restic-runner bash -c "
                                echo '=== Snapshots r√©cents ==='
                                restic snapshots --compact | tail -10
                                
                                echo '=== Statistiques du repository ==='
                                restic stats --mode raw-data
                            "
                    '''
                }
            }
        }

        stage('Restore Test') {
            when {
                expression { return params.RUN_RESTORE_TEST == true }
            }
            steps {
                script {
                    echo "üîÑ Test de restauration..."
                }
                
                withCredentials([
                    file(credentialsId: 'restic-password-file', variable: 'RESTIC_PASSWORD_FILE'),
                    string(credentialsId: 'minio-access-key', variable: 'AWS_ACCESS_KEY_ID'),
                    string(credentialsId: 'minio-secret-key', variable: 'AWS_SECRET_ACCESS_KEY')
                ]) {
                    sh '''
                        echo "üß™ Test de restauration du chemin: ${RESTORE_PATH}"
                        
                        # Copier le fichier de mot de passe dans le conteneur
                        docker exec restic-runner mkdir -p /secrets
                        docker cp "$RESTIC_PASSWORD_FILE" restic-runner:/secrets/restic_password
                        docker exec restic-runner chmod 600 /secrets/restic_password
                        
                        # Test de restauration
                        docker exec \
                            -e RESTIC_REPOSITORY \
                            -e AWS_ACCESS_KEY_ID \
                            -e AWS_SECRET_ACCESS_KEY \
                            -e RESTIC_PASSWORD_FILE=/secrets/restic_password \
                            restic-runner bash -c "
                                # Nettoyage du r√©pertoire de test
                                rm -rf /restore-test
                                mkdir -p /restore-test
                                
                                # Test de restauration
                                /backup-scripts/restore.sh /restore-test '${RESTORE_PATH}' latest
                                
                                echo '=== Contenu restaur√© ==='
                                find /restore-test -type f | head -10
                                echo 'Total fichiers restaur√©s: \$(find /restore-test -type f | wc -l)'
                                
                                # Nettoyage
                                rm -rf /restore-test
                            "
                    '''
                }
            }
        }
    }

    post {
        always {
            script {
                echo "üßπ Nettoyage post-sauvegarde..."
                // Nettoyage des fichiers temporaires si n√©cessaire
            }
        }
        
        success {
            script {
                echo "‚úÖ Pipeline de sauvegarde termin√© avec succ√®s"
                // Notification de succ√®s (Slack, email, etc.)
            }
        }
        
        failure {
            script {
                echo "‚ùå √âchec du pipeline de sauvegarde"
                // Notification d'√©chec (Slack, email, etc.)
            }
        }
        
        cleanup {
            script {
                // Nettoyage final
                sh '''
                    # Nettoyage des secrets temporaires dans le conteneur
                    docker exec restic-runner sh -c 'rm -rf /secrets /restore-test' || true
                '''
            }
        }
    }
}
